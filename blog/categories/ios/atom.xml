<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Ian's Tech Note]]></title>
  <link href="http://iandai.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://iandai.github.io/"/>
  <updated>2016-08-20T23:29:17+08:00</updated>
  <id>http://iandai.github.io/</id>
  <author>
    <name><![CDATA[Ian Dai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Optional in Swift -- 使用Swift Optional的好处]]></title>
    <link href="http://iandai.github.io/blog/2016/08/20/optional-in-swift-shi-yong-swift-optionalde-hao-chu/"/>
    <updated>2016-08-20T22:57:38+08:00</updated>
    <id>http://iandai.github.io/blog/2016/08/20/optional-in-swift-shi-yong-swift-optionalde-hao-chu</id>
    <content type="html"><![CDATA[<p>看这篇文章之前，需要了解Swift中<a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson1.html#//apple_ref/doc/uid/TP40015214-CH3-SW1">Optional的基础知识</a>。</p>

<p>作为写了几年的Objective-c的开发者，对在Swift中使用Optional持有过怀疑态度。使用了Optional，需要添加烦人的？和！。使用了？和！之后，依然需要做nil检查；使用了Value！之后，依然会在运行时因为nil问题而crash。</p>

<p>使用Optional有什么意义呢？</p>

<h2>使用理由1: 预先定义好通用的对象不存在的时候的写法</h2>

<p>考虑下面的例子：</p>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return nil;
}
</code></pre>

<p>可以使用findStockCode:方法来获取某个上市公司的股票代码。<br/>
也有的开发者会使用下面的方法来写，找不到的时候返回空字符串。</p>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return "";
}
</code></pre>

<p>如何确定找不到该公司代码的时候，返回的是空字符串还是nil呢？调用该方法的开发者，需要阅读文档或者处理多种情况。</p>

<pre><code class="objc">NSString *stockCode = [self findStockCode:@"Facebook"]; 
if (stockCode == "" &amp;&amp; stockCode == nil) {
    .....
}
</code></pre>

<p>在Swift中，这种情况非常明显的要使用Optional。如果找不到，则返回nil。</p>

<pre><code class="swift">func findStockCode (company : String) -&gt; String? {
    if (company == "Apple") {
        return "AAPL"
    } else if(company == "Google") {
        return "GOOG"
    }

    return nil
}
</code></pre>

<h2>使用理由2: 编译的时候提示错误</h2>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return nil;
}

NSString *stockCode = [self findStockCode:@"Facebook"]; // nil is returned
NSString *text = @"Stock Code - ";
NSString *message = [text stringByAppendingString:stockCode]; // runtime error
NSLog(@"%@", message);
</code></pre>

<p>当用Objective-C的时候，<code>[text stringByAppendingString:stockCode]</code>中，给NSString添加nil的时候，在运行时出错。</p>

<pre><code class="swift">func findStockCode(company: String) -&gt; String? {
   if (company == "Apple") {
      return "AAPL"
   } else if (company == "Google") {
      return "GOOG"
   }

   return nil
}

var stockCode:String? = findStockCode("Facebook")
let text = "Stock Code - "
let message = text + stockCode  // compile-time error
print(message)
</code></pre>

<p>当用Swift的时候，<code>let message = text + stockCode</code>中，Xcode会主动提示stockCode可能会是nil的情况，需要开发者进一步处理。</p>

<h2>使用理由3: 强迫思考nil问题，crash容易发现问题</h2>

<p>上面的Swift代码中，要解决complile-time error，可以用加！来forced unwrapping。</p>

<pre><code class="swift">var stockCode:String? = findStockCode("Facebook")
let text = "Stock Code - "
let message = text + stockCode!  // runtime error
</code></pre>

<p>这段代码可以通过编译，但是在runtime的时候，还是会出错。<br/>
抛出：“fatal error: Can’t unwrap Optional.None”。<br/>
在使用！进行forced unwrapping的时候，开发者被迫思考是要forced unwrapping，还是stockCode有可能是nil。<br/>
这有利于减少犯错的机会。而如果出错了，提示的消息也非常容易找到问题所在。</p>

<h2>使用理由4: 简化nil检查写法(optional chaining)</h2>

<p>考虑这个例子</p>

<pre><code class="swift">class Stock {
    var code: String? 
    var price: Double? 
}

func findStockCode(company: String) -&gt; Stock? {
    if (company == "Apple") {
        let aapl: Stock = Stock()
        aapl.code = "AAPL"
        aapl.price = 90.32

        return aapl
    } else if (company == "Google") {
        let goog: Stock = Stock()
        goog.code = "GOOG"
        goog.price = 556.36

        return goog
    }

    return nil
}

if let sharePrice = findStockCode("Apple")?.price {
    let totalCost = sharePrice * 100
    print(totalCost)
}
</code></pre>

<p>在这段代码中，进行了2次nil检查，一次是判断findStockCode(&ldquo;Apple&rdquo;)是否为nil，一次是判断findStockCode(&ldquo;Apple&rdquo;).price是否为nil。使用optional chaining，可以简化nil检查写法。</p>

<h3>参考文献</h3>

<p><a href="https://www.appcoda.com/beginners-guide-optionals-swift/">A Beginner’s Guide to Optionals in Swift</a><br/>
<a href="http://blog.teamtreehouse.com/understanding-optionals-swift">Understanding Optionals in Swift</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模仿UIAlertView的一个Rotatable Overlay View — RTOverlayWindow]]></title>
    <link href="http://iandai.github.io/blog/2015/10/09/mo-fang-uialertviewde-%5B%3F%5D-ge-rotatable-overlay-view-rtoverlaywindow/"/>
    <updated>2015-10-09T21:37:41+08:00</updated>
    <id>http://iandai.github.io/blog/2015/10/09/mo-fang-uialertviewde-[?]-ge-rotatable-overlay-view-rtoverlaywindow</id>
    <content type="html"><![CDATA[<p>在写customised alert view的时候，遇到了一些问题，于是写了RTOverlayWindow。</p>

<p>最简单添加OverlayView的方法（苹果官方并不推荐使用这种方法），就是</p>

<pre><code class="objc">    UIWindow *keyWindow = [[UIApplication sharedApplication] keyWindow];
    [keyWindow addSubview:someCustomizedView];
</code></pre>

<p>使用上面的方法，添加的<code>someCustomizedView</code>无法自动旋转。
对无法自动旋转，最合理的解决方法，是把这个view放到一个UIViewController里面管理。</p>

<p>但是，还是希望有一种简单的方法，和使用UIAlertView一样，只是单纯的添加一个简单的view，就可以方便的使用。<br/>
于是研究了一下UIAlertView的实现。</p>

<p>在iOS7中，在界面有UIAlertView弹出的状态下，使用<code>po [[UIWindow keyWindow] recursiveDescription]</code>可以看到当前UIAlertView的view结构。</p>

<pre><code>&lt;_UIModalItemHostingWindow: 0x7af46ee0; frame = (0 0; 320 480); gestureRecognizers = &lt;NSArray: 0x7af473e0&gt;; layer = &lt;UIWindowLayer: 0x7af47060&gt;&gt;
   | &lt;UIView: 0x7af46dd0; frame = (0 0; 320 480); opaque = NO; autoresize = W+H; layer = &lt;CALayer: 0x7af46d60&gt;&gt;
   | &lt;UIView: 0x7af49800; frame = (0 0; 320 480); opaque = NO; autoresize = W+H; layer = &lt;CALayer: 0x7af49860&gt;&gt;
   |    | &lt;UIView: 0x7b2561f0; frame = (0 0; 320 480); layer = &lt;CALayer: 0x7b256250&gt;&gt;
   |    | &lt;_UIModalItemRepresentationView: 0x7b255d90; frame = (25 178; 270 124); layer = &lt;CALayer: 0x7b255ea0&gt;&gt;
   |    |    | &lt;_UIModalItemAlertBackgroundView: 0x7af30f80; frame = (0 0; 270 124); animations = { &lt;_UIParallaxMotionEffect: 0x7af4c470&gt;=&lt;CAAnimationGroup: 0x7b25e510&gt;; }; layer = &lt;CALayer: 0x7af312e0&gt;&gt;
   |    |    |    | &lt;_UIBackdropView: 0x7af3de20; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;_UIBackdropViewLayer: 0x7af4a290&gt;&gt;
   |    |    |    |    | &lt;_UIBackdropEffectView: 0x7af4ab30; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CABackdropLayer: 0x7af4ae50&gt;&gt;
   |    |    |    |    | &lt;UIView: 0x7af4b150; frame = (0 0; 270 124); hidden = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7af4b5c0&gt;&gt;
   |    |    |    | &lt;UIImageView: 0x7af3b830; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7af47020&gt;&gt;
   |    |    | &lt;_UIModalItemAlertContentView: 0x7af45b50; frame = (0 0; 270 124); clipsToBounds = YES; animations = { &lt;_UIParallaxMotionEffect: 0x7af4c470&gt;=&lt;CAAnimationGroup: 0x7b25ec90&gt;; }; layer = &lt;CALayer: 0x7af45cf0&gt;&gt;
   |    |    |    | &lt;UITableView: 0x7cb96000; frame = (135 80; 135 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b236eb0&gt;; layer = &lt;CALayer: 0x7b236960&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UITableViewWrapperView: 0x7b2378f0; frame = (0 0; 135 44); autoresize = W+H; layer = &lt;CALayer: 0x7b237a00&gt;&gt;
   |    |    |    |    |    | &lt;_UIModalItemTableViewCell: 0x7b2648c0; frame = (0 0; 135 44); text = 'OK'; autoresize = W; layer = &lt;CALayer: 0x7b256010&gt;&gt;
   |    |    |    |    |    |    | &lt;UITableViewCellScrollView: 0x7b264a60; frame = (0 0; 135 44); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7b237d50&gt;; layer = &lt;CALayer: 0x7b2604b0&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    |    |    |    | &lt;UITableViewCellContentView: 0x7b2520e0; frame = (0 0; 135 43.5); gestureRecognizers = &lt;NSArray: 0x7b261de0&gt;; layer = &lt;CALayer: 0x7b261220&gt;&gt;
   |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7b264d30; frame = (15 0; 105 43.5); text = 'OK'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b255ed0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b2577b0; frame = (131.5 37; 3.5 7); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b257880&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b2571d0; frame = (128 40.5; 7 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b257420&gt;&gt;
   |    |    |    | &lt;UIScrollView: 0x7b238430; frame = (0 0; 270 61); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b2389a0&gt;; layer = &lt;CALayer: 0x7b238680&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UILabel: 0x7b2337a0; frame = (15 19; 240 21); text = 'title'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b233850&gt;&gt;
   |    |    |    |    | &lt;UILabel: 0x7b2340a0; frame = (15 44; 240 17); text = 'message'; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b233950&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b258bd0; frame = (0 57.5; 270 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b258ca0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b258da0; frame = (266.5 0; 3.5 61); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b258e70&gt;&gt;
   |    |    |    | &lt;UIView: 0x7b2541d0; frame = (0 79.5; 270 0.5); layer = &lt;CALayer: 0x7b254230&gt;&gt;
   |    |    |    | &lt;UITableView: 0x7cbc7400; frame = (0 80; 135 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b254320&gt;; layer = &lt;CALayer: 0x7b2542b0&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UITableViewWrapperView: 0x7b254620; frame = (0 0; 135 44); autoresize = W+H; layer = &lt;CALayer: 0x7b254710&gt;&gt;
   |    |    |    |    |    | &lt;_UIModalItemTableViewCell: 0x7b25fb20; frame = (0 0; 135 44); text = 'cancel'; autoresize = W; layer = &lt;CALayer: 0x7b25fe00&gt;&gt;
   |    |    |    |    |    |    | &lt;UITableViewCellScrollView: 0x7b2600c0; frame = (0 0; 135 44); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7b236cf0&gt;; layer = &lt;CALayer: 0x7b260330&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    |    |    |    | &lt;UITableViewCellContentView: 0x7b2368e0; frame = (0 0; 135 43.5); gestureRecognizers = &lt;NSArray: 0x7b256cd0&gt;; layer = &lt;CALayer: 0x7b237f90&gt;&gt;
   |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7b237a30; frame = (15 0; 105 43.5); text = 'cancel'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b25b8a0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b259200; frame = (131.5 37; 3.5 7); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b2592d0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b259020; frame = (128 40.5; 7 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b2590f0&gt;&gt;
   |    |    |    | &lt;UIView: 0x7b254820; frame = (135 80; 0.5 44); layer = &lt;CALayer: 0x7b254880&gt;&gt;
</code></pre>

<p>在iOS8中UIVAlertView结构如下。
&#8220;`
&lt;<em>UIAlertControllerShimPresenterWindow: 0x7bbbfaa0; frame = (0 0; 768 1024); opaque = NO; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7bbc0600>; layer = &lt;UIWindowLayer: 0x7bbbfcf0>>
   | &lt;UIView: 0x7bd727b0; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x7bd72820>>
   | &lt;UITransitionView: 0x7a7bcb20; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x7a7bccd0>>
   |    | &lt;UIView: 0x7a68fd90; frame = (0 0; 768 1024); layer = &lt;CALayer: 0x7a68fe00>>
   |    | &lt;</em>UIKeyboardLayoutAlignmentView: 0x7a68fab0; frame = (0 1024; 768 0); layer = &lt;CALayer: 0x7a68fc60>>
   |    | &lt;UIView: 0x7a68f8e0; frame = (0 0; 768 1024); layer = &lt;CALayer: 0x7a68f890>>
   |    | &lt;<em>UIAlertControllerView: 0x7a695f70; frame = (249 451; 270 122); layer = &lt;CALayer: 0x7a6961e0>>
   |    |    | &lt;UIView: 0x7a696350; frame = (0 0; 270 122); animations = { &lt;</em>UIParallaxMotionEffect: 0x7a792160>=&lt;CAAnimationGroup: 0x7a7b2380>; }; layer = &lt;CALayer: 0x7a6963c0>>
   |    |    |    | &lt;<em>UIDimmingKnockoutBackdropView: 0x7a69fd90; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a689fa0>>
   |    |    |    |    | &lt;UIView: 0x7a68a490; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a687850>>
   |    |    |    |    | &lt;</em>UIBackdropView: 0x7a69fe00; frame = (0 0; 270 122); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;<em>UIBackdropViewLayer: 0x7a692a40>>
   |    |    |    |    |    | &lt;UIView: 0x7a694d00; frame = (0 0; 270 122); opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a6746d0>>
   |    |    |    | &lt;UIView: 0x7a696410; frame = (0 0; 270 122); layer = &lt;CALayer: 0x7a696480>>
   |    |    |    |    | &lt;UIView: 0x7a6964d0; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a696540>>
   |    |    |    |    |    | &lt;</em>UIAlertControllerShadowedScrollView: 0x7a6966b0; frame = (0 0; 270 78); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7a696e60>; layer = &lt;CALayer: 0x7a6969c0>; contentOffset: {0, 0}; contentSize: {270, 78}>
   |    |    |    |    |    |    | &lt;UIView: 0x7a6975c0; frame = (0 0; 270 78); layer = &lt;CALayer: 0x7a697630>>
   |    |    |    |    |    |    |    | &lt;UILabel: 0x7a698580; frame = (16 20; 238 21); text = &lsquo;11&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7a698240>>
   |    |    |    |    |    |    |    | &lt;UILabel: 0x7a69ab30; frame = (16 42; 238 16); text = &lsquo;22&rsquo;; userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7a69abf0>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7a69ad70; frame = (135 -451; 0 0); clipsToBounds = YES; layer = &lt;CALayer: 0x7a69ade0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a787b60; frame = (0 75; 270 3); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a787e70>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a788610; frame = (267 902; 3 78); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a788690>>
   |    |    |    |    |    | &lt;UICollectionView: 0x7a984a00; frame = (0 78; 270 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7a69bd70>; layer = &lt;CALayer: 0x7a69bad0>; contentOffset: {0, 0}; contentSize: {270, 44}> collection view layout: &lt;<em>UIAlertControllerCollectionViewFlowLayout: 0x7a69b1d0>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerCollectionViewCell: 0x7bbbaec0; frame = (0 1; 135 44); layer = &lt;CALayer: 0x7bbbd730>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7bbbc4a0; frame = (0 0; 135 44); gestureRecognizers = &lt;NSArray: 0x7bbb11b0>; layer = &lt;CALayer: 0x7bbc2110>>
   |    |    |    |    |    |    |    |    | &lt;<em>UIAlertControllerActionView: 0x7bbbc100; frame = (0 0; 135 44); Action = &lt;UIAlertAction: 0x7bbbf640 Title = &ldquo;cancel&rdquo; Descriptive = &ldquo;(null)&rdquo; Image = 0x0>>
   |    |    |    |    |    |    |    |    |    | &lt;</em>UIBlendingHighlightView: 0x7bbc5640; frame = (0 0; 135 44); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbc5810>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc56e0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbc4dd0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc5790; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbc6580>>
   |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc28e0; frame = (12 0; 111 0); layer = &lt;CALayer: 0x7bb68f30>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbbc1c0; frame = (0 12; 111 21); text = &lsquo;cancel&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7bbbd3e0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbbc280; frame = (-12 22; 0 0); userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7bbc1c50>>
   |    |    |    |    |    |    |    |    |    |    |    | &lt;<em>UILabelContentLayer: 0x7a7b5620> (layer)
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbbc340; frame = (12 22; 0 0); userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbbc3c0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbbfe30; frame = (109 15; 14 14); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbc2d30>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerCollectionViewCell: 0x7bbcd6c0; frame = (135 1; 135 44); layer = &lt;CALayer: 0x7bbcd2a0>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7bbcd760; frame = (0 0; 135 44); gestureRecognizers = &lt;NSArray: 0x7bbcd950>; layer = &lt;CALayer: 0x7bbcd7d0>>
   |    |    |    |    |    |    |    |    | &lt;<em>UIAlertControllerActionView: 0x7bbcd980; frame = (0 0; 135 44); Action = &lt;UIAlertAction: 0x7bbbf7c0 Title = &ldquo;OK&rdquo; Descriptive = &ldquo;(null)&rdquo; Image = 0x0>>
   |    |    |    |    |    |    |    |    |    | &lt;</em>UIBlendingHighlightView: 0x7bbd0550; frame = (0 0; 135 44); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbd1e30>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbd05f0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbd0060>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbd06a0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbd2bf0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbcda70; frame = (12 0; 111 0); layer = &lt;CALayer: 0x7bbcdae0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbcdb10; frame = (0 12; 111 21); text = &lsquo;OK&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7bbcdbd0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbcdd20; frame = (-12 22; 0 0); userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7bbcdde0>>
   |    |    |    |    |    |    |    |    |    |    |    | &lt;<em>UILabelContentLayer: 0x7a7b50d0> (layer)
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbcdf30; frame = (12 22; 0 0); userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbcdfb0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbcdfe0; frame = (109 15; 14 14); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbce060>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerBlendingSeparatorView: 0x7a7739b0; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a78d6b0>>
   |    |    |    |    |    |    |    | &lt;<em>UIBlendingHighlightView: 0x7a774ac0; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a7926e0>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a77f430; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a792760>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a785440; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a7927c0>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerBlendingSeparatorView: 0x7a780ab0; frame = (135 1; 1 43); layer = &lt;CALayer: 0x7a79d5a0>>
   |    |    |    |    |    |    |    | &lt;_UIBlendingHighlightView: 0x7a78c490; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a7928e0>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a7beba0; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a792960>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a772d20; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a7929e0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a789f20; frame = (0 41; 270 3); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a789fa0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a78a3e0; frame = (267 0; 3 44); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a78a460>></p>

<p>&#8220;`</p>

<p>可以看到，虽然UIAlertView在iOS7和iOS8中实现方法不同，但都是新建了一个UIWindow，并设为keyWindow。<br/>
模仿UIAlertView的方式，做了<a href="https://github.com/iandai/RTOverlayWindow">RTOverlayWindow</a>。<br/>
需要注意的是，使用多层UIWindow也是苹果所不推荐的方法，不过有时候在代码结构本身不合理的情况下，也是一种不错的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[facebook如何重构优化Messenger性能（摘要）]]></title>
    <link href="http://iandai.github.io/blog/2015/09/24/facebookru-he-zhong-gou-you-hua-messengerxing-neng-(zhai-yao-)/"/>
    <updated>2015-09-24T17:41:42+08:00</updated>
    <id>http://iandai.github.io/blog/2015/09/24/facebookru-he-zhong-gou-you-hua-messengerxing-neng-(zhai-yao-)</id>
    <content type="html"><![CDATA[<h2>facebook如何重构优化Messenger性能（摘要）</h2>

<h3>Messenger最开始是facebook站内信，后来演化为实时的聊天App。Messenger的性能和过度消耗网络数据流量的问题开始拖系统后退。针对这个问题facebook做了一次重构。主要做了以下工作：</h3>

<ul>
<li>在客户端方面，把pull-based模式，改成了push-based snapshot + delta模式。用Thrift替换了JSON格式，减小数据size。</li>
<li>在服务端方面，自建的Iris服务，减少了将聊天消息写入磁盘再读取出来的时间。</li>
</ul>


<h4>参考文献</h4>

<ul>
<li><a href="https://code.facebook.com/posts/820258981365363/building-mobile-first-infrastructure-for-messenger">Building Mobile-First Infrastructure for Messenger</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App如何正确的要求用户同意获取系统权限（摘要）]]></title>
    <link href="http://iandai.github.io/blog/2015/09/24/ios-appru-he-zheng-que-de-yao-qiu-yong-hu-tong-yi-huo-qu-xi-tong-quan-xian-(zhai-yao-)/"/>
    <updated>2015-09-24T17:30:22+08:00</updated>
    <id>http://iandai.github.io/blog/2015/09/24/ios-appru-he-zheng-que-de-yao-qiu-yong-hu-tong-yi-huo-qu-xi-tong-quan-xian-(zhai-yao-)</id>
    <content type="html"><![CDATA[<h2>iOS App如何正确的要求用户同意获取系统权限（摘要）</h2>

<ul>
<li>App下载后，第一次初始化的时候，弹出对话框，要求获取系统权限。成功率只有30%－40%。这种方法不推荐。</li>
<li>在给用户介绍App功能的界面，解释为什么需要获取某一项系统权限，并弹出对话框。成功率有40% - 66%。这种方法也不推荐。</li>
<li>在用户进行某项操作，必须使用到某一项系统权限的时候，弹出App自定义的对话框，解释为何需要获取某一项系统权限。如果用户点击同意，那么再弹出系统的权限获取对话框。如果用户点击不同意，那么App就不执行该功能，告诉用户要做的操作失败。利用这种方法，有时候成功率可以达到100%。</li>
</ul>


<h4>参考文献</h4>

<ul>
<li><a href="http://techcrunch.com/2014/04/04/the-right-way-to-ask-users-for-ios-permissions/">The Right Way To Ask Users For iOS Permissions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS在删除App的情况下，仍然会记忆App Camera访问权限的reset方法]]></title>
    <link href="http://iandai.github.io/blog/2015/09/24/iozai-shan-chu-appde-qing-kuang-xia-,reng-ran-hui-ji-yi-app-camerafang-wen-quan-xian-de-resetfang-fa/"/>
    <updated>2015-09-24T16:50:50+08:00</updated>
    <id>http://iandai.github.io/blog/2015/09/24/iozai-shan-chu-appde-qing-kuang-xia-,reng-ran-hui-ji-yi-app-camerafang-wen-quan-xian-de-resetfang-fa</id>
    <content type="html"><![CDATA[<h2>重设App相机访问权限方法</h2>

<ul>
<li>iOS在删除App的情况下，仍然会记忆App camera访问权限1天</li>
<li>重设方法一：调整系统时间。</li>
<li>重设方法二：修改App的bundle id。</li>
<li>重设方法三：重设所有App的位置和隐私。Settings -> General -> Reset -> Rest Location &amp; Privacy</li>
</ul>


<h4>参考文献</h4>

<ul>
<li><a href="http://stackoverflow.com/questions/27726354/ipad-remembering-camera-permissions-after-delete-how-to-clear">重设相机访问权限</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
