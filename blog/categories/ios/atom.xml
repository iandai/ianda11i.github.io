<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Ian's Tech Note]]></title>
  <link href="http://iandai.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://iandai.github.io/"/>
  <updated>2018-06-24T23:43:43+02:00</updated>
  <id>http://iandai.github.io/</id>
  <author>
    <name><![CDATA[Ian Dai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSString, Unicode和NSCharacterSet]]></title>
    <link href="http://iandai.github.io/blog/2017/01/05/nsstring-unicodehe-nscharacterset/"/>
    <updated>2017-01-05T15:57:17+01:00</updated>
    <id>http://iandai.github.io/blog/2017/01/05/nsstring-unicodehe-nscharacterset</id>
    <content type="html"><![CDATA[<h2>Unicode</h2>

<h3>Convert unicode ponit to eomji using universal character names</h3>

<blockquote><p>Universal character names are formed by a prefix \U followed by an eight-digit Unicode code point, or by a prefix \u followed by a four digit Unicode code point.
For Unicode surrogate pairs, specify the universal character name by using \UNNNNNNNN, where NNNNNNNN is the eight-digit code point for the character. The compiler generates a surrogate pair if required.
In Objc, \U also handles Emoji ZWJ Sequences.</p></blockquote>

<p>For example:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 用Universal character names \U和\u 替换
</span><span class='line'>NSString *str = @&ldquo;The Greek letter Beta looks like this: \u03b2, and the emoji for books looks like this: \U00010437&rdquo;;
</span><span class='line'>NSLog(@&ldquo;%@&rdquo;, str);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;// 处理 Surrogate Pairs
</span><span class='line'>// 方法一
</span><span class='line'>NSString *str2 = [NSString stringWithCharacters:(unichar[]){0x263A, 0xFE0F} length:2];
</span><span class='line'>NSLog(@"%@", str2);
</span><span class='line'>// 方法二
</span><span class='line'>NSString *str3 = [NSString stringWithFormat:@"\U0000263A\U0000FE0F"];
</span><span class='line'>NSLog(@"%@", str3);
</span><span class='line'>// 方法三
</span><span class='line'>// NSString  initWithBytes
</span><span class='line'>// supports Surrogate Pairs, does not support Emoji ZWJ Sequences
</span><span class='line'>const unichar chars1[] = {0x263A, 0xFE0F};
</span><span class='line'>NSString *str4 = [[NSString alloc] initWithBytes:chars1 length:sizeof(chars1) encoding:NSUTF16LittleEndianStringEncoding];
</span><span class='line'>NSLog(@"%@", str4);
</span><span class='line'>// 方法四
</span><span class='line'>// NSString  initWithBytes
</span><span class='line'>// works on utf32
</span><span class='line'>uint32_t base_point_UTF32 = 0x1F600;
</span><span class='line'>NSString *str5 = [[NSString alloc] initWithBytes:&amp;base_point_UTF32 length:4 encoding:NSUTF32LittleEndianStringEncoding];
</span><span class='line'>NSLog(@"%@", str5);
</span><span class='line'>// 方法五
</span><span class='line'>//CFStringGetSurrogatePairForLongCharacter
</span><span class='line'>UniChar c[2];
</span><span class='line'>CFStringGetSurrogatePairForLongCharacter(0x1F600, c);
</span><span class='line'>NSString *str6 = [[NSString alloc] initWithCharacters:c length:2];
</span><span class='line'>NSLog(@"%@", str6);
</span><span class='line'>
</span><span class='line'>// 处理Emoji ZWJ Sequences
</span><span class='line'>// 方法一
</span><span class='line'>NSString *str7 = [NSString stringWithFormat:@"\U0001F468\U0000200D\U00002695\U0000FE0F"];
</span><span class='line'>NSLog(@"%@", str7);
</span><span class='line'>// 方法二
</span><span class='line'>NSString *str8 = [NSString stringWithFormat:@"👨\u200D👩\u200D👧\u200D👦"]; //👨‍👩‍👧‍👦
</span><span class='line'>NSLog(@"%@", str8);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>
</span><span class='line'>## CharacterSet
</span><span class='line'>
</span><span class='line'>### 检测CharacterSet包含了哪些字符
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NSCharacterSet *charSet = [NSCharacterSet symbolCharacterSet];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;int count = 1;
</span><span class='line'>for (unichar i = 0; i&lt;65535; i++) {
</span><span class='line'>if ([charSet characterIsMember:i]) {
</span><span class='line'>    NSLog(@&ldquo;character %d = %C&rdquo;,i,i);
</span><span class='line'>    count++;
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>NSLog(@&ldquo;found %d characters out of 65536&rdquo;,count);</span></code></pre></td></tr></table></div></figure></p>

<h2>More about unicode and emoji</h2>

<p><a href="http://www.unicode.org/faq/emoji_dingbats.html">Emoji and Pictographs</a><br/>
<a href="http://cyrilwei.me/swift/2016/08/31/the-emoji.html">The Emoji, is not what you expected</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何检测和删除NSString中的颜文字Emoji]]></title>
    <link href="http://iandai.github.io/blog/2017/01/05/ru-he-jian-ce-he-shan-chu-nsstringzhong-de-yan-wen-zi-emoji/"/>
    <updated>2017-01-05T14:52:29+01:00</updated>
    <id>http://iandai.github.io/blog/2017/01/05/ru-he-jian-ce-he-shan-chu-nsstringzhong-de-yan-wen-zi-emoji</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>有一个需求是获取联系人姓名的首字母，使用一个或多个首字母绘制联系人用户头像。有的用户名字首字母是颜文字，绘制就会出现乱码。代码如下：</p>

<pre><code class="Objc">NSMutableString *initials = [NSMutableString string];
NSArray *words = [contactName componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
for (NSString *word in words) {
    if (word.length &gt; 0) {
        NSString *firstLetter = [word substringToIndex:1];
        [initials appendString:[firstLetter uppercaseString]];
    }
}
</code></pre>

<p>乱码来自于名字中的颜文字，当<code>[word substringToIndex:1]</code>中的word是颜文字的时候，其返回值并不是一个正常的颜文字。</p>

<p>原因是<code>[word length]</code>结果是2，所以<code>[word substringToIndex:1]</code>其实只返回了颜文字的一半。</p>

<p>为什么会出现这种情况呢？这是因为<code>word</code>是一个NSString类型，而NSString是UTF-16编码的。许多颜文字在使用UTF-16表示的时候，要是用两个字节才能表示，比如😀。</p>

<p>NSString类的<a href="https://developer.apple.com/reference/foundation/nsstring">文档</a>里写到：</p>

<blockquote><p>An NSString object encodes a Unicode-compliant text string, represented as a sequence of UTF–16 code units. All lengths, character
indexes, and ranges are expressed in terms of 16-bit platform-endian values, with index values starting at 0.</p></blockquote>

<h2>解决方法</h2>

<h3>1.从字符串中获得正确完整的字符</h3>

<pre><code class="Objc">__block NSString *firstLetter = @"";
[word enumerateSubstringsInRange:NSMakeRange(0, [word length])
                         options:NSStringEnumerationByComposedCharacterSequences
                      usingBlock: ^(NSString* substring, NSRange substringRange, NSRange enclosingRange, BOOL* stop) {
                          firstLetter = substring;
                          *stop = YES;
                      }];
</code></pre>

<p>使用<code>NSStringEnumerationByComposedCharacterSequences</code>能够读取完整的颜文字，而不是只读取其中一个字节。</p>

<h3>2.检测和删除是否包含颜文字</h3>

<p>Github上有一个比较多人参考的项目<a href="https://github.com/woxtu/NSString-RemoveEmoji">NSString-RemoveEmoj</a>。这个项目有遗漏颜文字，比如⭐，包含了许多不是颜文字的字符，比如Ⅶ。</p>

<p>在unicode.org网站上，有<a href="http://unicode.org/Public/emoji/4.0/emoji-test.txt">完整的颜文字列表</a>。遍历这个完整的列表，就可以检测字符串中是否颜文字。方法如下：</p>

<pre><code class="Objc">// 建立一个emoji CharacterSet
NSMutableCharacterSet *emojiCharacterSet = [[NSMutableCharacterSet alloc] init];
NSString *plistPath = [[NSBundle mainBundle] pathForResource:@"emoji" ofType:@"plist"];
NSArray *emojiArr = [NSArray arrayWithContentsOfFile:plistPath];
for (NSString *emoji in emojiArr) {
    [emojiCharacterSet addCharactersInString:emoji];
}

// - (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)searchSet;
[@"😀" rangeOfCharacterFromSet:set]; 
</code></pre>

<p>上面代码还有一个问题没有被考虑。比如下面这种情况：</p>

<pre><code class="Objc">
NSMutableCharacterSet *set = [[NSMutableCharacterSet alloc] init];
[set addCharactersInString:@"2️⃣"];      // keycap 2, 0032 FE0F 20E3, check from http://www.iemoji.com/view/emoji/296/symbols/keycap-2 
[@"2" rangeOfCharacterFromSet:set];     // return value: YES, which is not reasonable 
</code></pre>

<p>字符2在搜索包含有颜文字2的字符集的时候，会被错误的检测出来。</p>

<p>为了解决这个问题，我写了<a href="https://github.com/iandai/IDEmojiString">IDEmojiString项目</a>。</p>

<h3>3.IDEmojiString</h3>

<p>IDEmojiString通过使单字符和多字符分别搜索字符集，解决了上面的问题。</p>

<p>使用CocoaPods安装之后，通过以下方法使用：
<code>Objc
//#import "IDEmojiManager.h"
IDEmojiManager *manager = [[IDEmojiManager alloc] init];
BOOL containsEmoji = [manager containEmojiInString:@"Some String⭐"];  // return value: YES
NSString *str = [manager removeEmojiFromString:@"Some String⭐"];      // return value: Some String
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optional in Swift -- 使用Swift Optional的好处]]></title>
    <link href="http://iandai.github.io/blog/2016/08/20/optional-in-swift-shi-yong-swift-optionalde-hao-chu/"/>
    <updated>2016-08-20T16:57:38+02:00</updated>
    <id>http://iandai.github.io/blog/2016/08/20/optional-in-swift-shi-yong-swift-optionalde-hao-chu</id>
    <content type="html"><![CDATA[<p>看这篇文章之前，需要了解Swift中<a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson1.html#//apple_ref/doc/uid/TP40015214-CH3-SW1">Optional的基础知识</a>。</p>

<p>作为写了几年的Objective-c的开发者，对在Swift中使用Optional持有过怀疑态度。使用了Optional，需要添加烦人的？和！。使用了？和！之后，依然需要做nil检查；使用了Value！之后，依然会在运行时因为nil问题而crash。</p>

<p>使用Optional有什么意义呢？</p>

<h2>使用理由1: 预先定义好通用的对象不存在的时候的写法</h2>

<p>考虑下面的例子：</p>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return nil;
}
</code></pre>

<p>可以使用findStockCode:方法来获取某个上市公司的股票代码。<br/>
也有的开发者会使用下面的方法来写，找不到的时候返回空字符串。</p>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return "";
}
</code></pre>

<p>如何确定找不到该公司代码的时候，返回的是空字符串还是nil呢？调用该方法的开发者，需要阅读文档或者处理多种情况。</p>

<pre><code class="objc">NSString *stockCode = [self findStockCode:@"Facebook"]; 
if (stockCode == "" &amp;&amp; stockCode == nil) {
    .....
}
</code></pre>

<p>在Swift中，这种情况非常明显的要使用Optional。如果找不到，则返回nil。</p>

<pre><code class="swift">func findStockCode (company : String) -&gt; String? {
    if (company == "Apple") {
        return "AAPL"
    } else if(company == "Google") {
        return "GOOG"
    }

    return nil
}
</code></pre>

<h2>使用理由2: 编译的时候提示错误</h2>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return nil;
}

NSString *stockCode = [self findStockCode:@"Facebook"]; // nil is returned
NSString *text = @"Stock Code - ";
NSString *message = [text stringByAppendingString:stockCode]; // runtime error
NSLog(@"%@", message);
</code></pre>

<p>当用Objective-C的时候，<code>[text stringByAppendingString:stockCode]</code>中，给NSString添加nil的时候，在运行时出错。</p>

<pre><code class="swift">func findStockCode(company: String) -&gt; String? {
   if (company == "Apple") {
      return "AAPL"
   } else if (company == "Google") {
      return "GOOG"
   }

   return nil
}

var stockCode:String? = findStockCode("Facebook")
let text = "Stock Code - "
let message = text + stockCode  // compile-time error
print(message)
</code></pre>

<p>当用Swift的时候，<code>let message = text + stockCode</code>中，Xcode会主动提示stockCode可能会是nil的情况，需要开发者进一步处理。</p>

<h2>使用理由3: 强迫思考nil问题，crash容易发现问题</h2>

<p>上面的Swift代码中，要解决complile-time error，可以用加！来forced unwrapping。</p>

<pre><code class="swift">var stockCode:String? = findStockCode("Facebook")
let text = "Stock Code - "
let message = text + stockCode!  // runtime error
</code></pre>

<p>这段代码可以通过编译，但是在runtime的时候，还是会出错。<br/>
抛出：“fatal error: Can’t unwrap Optional.None”。<br/>
在使用！进行forced unwrapping的时候，开发者被迫思考是要forced unwrapping，还是stockCode有可能是nil。<br/>
这有利于减少犯错的机会。而如果出错了，提示的消息也非常容易找到问题所在。</p>

<h2>使用理由4: 简化nil检查写法(optional chaining)</h2>

<p>考虑这个例子</p>

<pre><code class="swift">class Stock {
    var code: String? 
    var price: Double? 
}

func findStockCode(company: String) -&gt; Stock? {
    if (company == "Apple") {
        let aapl: Stock = Stock()
        aapl.code = "AAPL"
        aapl.price = 90.32

        return aapl
    } else if (company == "Google") {
        let goog: Stock = Stock()
        goog.code = "GOOG"
        goog.price = 556.36

        return goog
    }

    return nil
}

if let sharePrice = findStockCode("Apple")?.price {
    let totalCost = sharePrice * 100
    print(totalCost)
}
</code></pre>

<p>在这段代码中，进行了2次nil检查，一次是判断findStockCode(&ldquo;Apple&rdquo;)是否为nil，一次是判断findStockCode(&ldquo;Apple&rdquo;).price是否为nil。使用optional chaining，可以简化nil检查写法。</p>

<h3>参考文献</h3>

<p><a href="https://www.appcoda.com/beginners-guide-optionals-swift/">A Beginner’s Guide to Optionals in Swift</a><br/>
<a href="http://blog.teamtreehouse.com/understanding-optionals-swift">Understanding Optionals in Swift</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模仿UIAlertView的一个Rotatable Overlay View — RTOverlayWindow]]></title>
    <link href="http://iandai.github.io/blog/2015/10/09/mo-fang-uialertviewde-%5B%3F%5D-ge-rotatable-overlay-view-rtoverlaywindow/"/>
    <updated>2015-10-09T15:37:41+02:00</updated>
    <id>http://iandai.github.io/blog/2015/10/09/mo-fang-uialertviewde-[?]-ge-rotatable-overlay-view-rtoverlaywindow</id>
    <content type="html"><![CDATA[<p>在写customised alert view的时候，遇到了一些问题，于是写了RTOverlayWindow。</p>

<p>最简单添加OverlayView的方法（苹果官方并不推荐使用这种方法），就是</p>

<pre><code class="objc">    UIWindow *keyWindow = [[UIApplication sharedApplication] keyWindow];
    [keyWindow addSubview:someCustomizedView];
</code></pre>

<p>使用上面的方法，添加的<code>someCustomizedView</code>无法自动旋转。
对无法自动旋转，最合理的解决方法，是把这个view放到一个UIViewController里面管理。</p>

<p>但是，还是希望有一种简单的方法，和使用UIAlertView一样，只是单纯的添加一个简单的view，就可以方便的使用。<br/>
于是研究了一下UIAlertView的实现。</p>

<p>在iOS7中，在界面有UIAlertView弹出的状态下，使用<code>po [[UIWindow keyWindow] recursiveDescription]</code>可以看到当前UIAlertView的view结构。</p>

<pre><code>&lt;_UIModalItemHostingWindow: 0x7af46ee0; frame = (0 0; 320 480); gestureRecognizers = &lt;NSArray: 0x7af473e0&gt;; layer = &lt;UIWindowLayer: 0x7af47060&gt;&gt;
   | &lt;UIView: 0x7af46dd0; frame = (0 0; 320 480); opaque = NO; autoresize = W+H; layer = &lt;CALayer: 0x7af46d60&gt;&gt;
   | &lt;UIView: 0x7af49800; frame = (0 0; 320 480); opaque = NO; autoresize = W+H; layer = &lt;CALayer: 0x7af49860&gt;&gt;
   |    | &lt;UIView: 0x7b2561f0; frame = (0 0; 320 480); layer = &lt;CALayer: 0x7b256250&gt;&gt;
   |    | &lt;_UIModalItemRepresentationView: 0x7b255d90; frame = (25 178; 270 124); layer = &lt;CALayer: 0x7b255ea0&gt;&gt;
   |    |    | &lt;_UIModalItemAlertBackgroundView: 0x7af30f80; frame = (0 0; 270 124); animations = { &lt;_UIParallaxMotionEffect: 0x7af4c470&gt;=&lt;CAAnimationGroup: 0x7b25e510&gt;; }; layer = &lt;CALayer: 0x7af312e0&gt;&gt;
   |    |    |    | &lt;_UIBackdropView: 0x7af3de20; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;_UIBackdropViewLayer: 0x7af4a290&gt;&gt;
   |    |    |    |    | &lt;_UIBackdropEffectView: 0x7af4ab30; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CABackdropLayer: 0x7af4ae50&gt;&gt;
   |    |    |    |    | &lt;UIView: 0x7af4b150; frame = (0 0; 270 124); hidden = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7af4b5c0&gt;&gt;
   |    |    |    | &lt;UIImageView: 0x7af3b830; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7af47020&gt;&gt;
   |    |    | &lt;_UIModalItemAlertContentView: 0x7af45b50; frame = (0 0; 270 124); clipsToBounds = YES; animations = { &lt;_UIParallaxMotionEffect: 0x7af4c470&gt;=&lt;CAAnimationGroup: 0x7b25ec90&gt;; }; layer = &lt;CALayer: 0x7af45cf0&gt;&gt;
   |    |    |    | &lt;UITableView: 0x7cb96000; frame = (135 80; 135 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b236eb0&gt;; layer = &lt;CALayer: 0x7b236960&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UITableViewWrapperView: 0x7b2378f0; frame = (0 0; 135 44); autoresize = W+H; layer = &lt;CALayer: 0x7b237a00&gt;&gt;
   |    |    |    |    |    | &lt;_UIModalItemTableViewCell: 0x7b2648c0; frame = (0 0; 135 44); text = 'OK'; autoresize = W; layer = &lt;CALayer: 0x7b256010&gt;&gt;
   |    |    |    |    |    |    | &lt;UITableViewCellScrollView: 0x7b264a60; frame = (0 0; 135 44); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7b237d50&gt;; layer = &lt;CALayer: 0x7b2604b0&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    |    |    |    | &lt;UITableViewCellContentView: 0x7b2520e0; frame = (0 0; 135 43.5); gestureRecognizers = &lt;NSArray: 0x7b261de0&gt;; layer = &lt;CALayer: 0x7b261220&gt;&gt;
   |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7b264d30; frame = (15 0; 105 43.5); text = 'OK'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b255ed0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b2577b0; frame = (131.5 37; 3.5 7); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b257880&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b2571d0; frame = (128 40.5; 7 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b257420&gt;&gt;
   |    |    |    | &lt;UIScrollView: 0x7b238430; frame = (0 0; 270 61); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b2389a0&gt;; layer = &lt;CALayer: 0x7b238680&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UILabel: 0x7b2337a0; frame = (15 19; 240 21); text = 'title'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b233850&gt;&gt;
   |    |    |    |    | &lt;UILabel: 0x7b2340a0; frame = (15 44; 240 17); text = 'message'; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b233950&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b258bd0; frame = (0 57.5; 270 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b258ca0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b258da0; frame = (266.5 0; 3.5 61); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b258e70&gt;&gt;
   |    |    |    | &lt;UIView: 0x7b2541d0; frame = (0 79.5; 270 0.5); layer = &lt;CALayer: 0x7b254230&gt;&gt;
   |    |    |    | &lt;UITableView: 0x7cbc7400; frame = (0 80; 135 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b254320&gt;; layer = &lt;CALayer: 0x7b2542b0&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UITableViewWrapperView: 0x7b254620; frame = (0 0; 135 44); autoresize = W+H; layer = &lt;CALayer: 0x7b254710&gt;&gt;
   |    |    |    |    |    | &lt;_UIModalItemTableViewCell: 0x7b25fb20; frame = (0 0; 135 44); text = 'cancel'; autoresize = W; layer = &lt;CALayer: 0x7b25fe00&gt;&gt;
   |    |    |    |    |    |    | &lt;UITableViewCellScrollView: 0x7b2600c0; frame = (0 0; 135 44); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7b236cf0&gt;; layer = &lt;CALayer: 0x7b260330&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    |    |    |    | &lt;UITableViewCellContentView: 0x7b2368e0; frame = (0 0; 135 43.5); gestureRecognizers = &lt;NSArray: 0x7b256cd0&gt;; layer = &lt;CALayer: 0x7b237f90&gt;&gt;
   |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7b237a30; frame = (15 0; 105 43.5); text = 'cancel'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b25b8a0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b259200; frame = (131.5 37; 3.5 7); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b2592d0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b259020; frame = (128 40.5; 7 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b2590f0&gt;&gt;
   |    |    |    | &lt;UIView: 0x7b254820; frame = (135 80; 0.5 44); layer = &lt;CALayer: 0x7b254880&gt;&gt;
</code></pre>

<p>在iOS8中UIVAlertView结构如下。
&#8220;`
&lt;<em>UIAlertControllerShimPresenterWindow: 0x7bbbfaa0; frame = (0 0; 768 1024); opaque = NO; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7bbc0600>; layer = &lt;UIWindowLayer: 0x7bbbfcf0>>
   | &lt;UIView: 0x7bd727b0; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x7bd72820>>
   | &lt;UITransitionView: 0x7a7bcb20; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x7a7bccd0>>
   |    | &lt;UIView: 0x7a68fd90; frame = (0 0; 768 1024); layer = &lt;CALayer: 0x7a68fe00>>
   |    | &lt;</em>UIKeyboardLayoutAlignmentView: 0x7a68fab0; frame = (0 1024; 768 0); layer = &lt;CALayer: 0x7a68fc60>>
   |    | &lt;UIView: 0x7a68f8e0; frame = (0 0; 768 1024); layer = &lt;CALayer: 0x7a68f890>>
   |    | &lt;<em>UIAlertControllerView: 0x7a695f70; frame = (249 451; 270 122); layer = &lt;CALayer: 0x7a6961e0>>
   |    |    | &lt;UIView: 0x7a696350; frame = (0 0; 270 122); animations = { &lt;</em>UIParallaxMotionEffect: 0x7a792160>=&lt;CAAnimationGroup: 0x7a7b2380>; }; layer = &lt;CALayer: 0x7a6963c0>>
   |    |    |    | &lt;<em>UIDimmingKnockoutBackdropView: 0x7a69fd90; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a689fa0>>
   |    |    |    |    | &lt;UIView: 0x7a68a490; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a687850>>
   |    |    |    |    | &lt;</em>UIBackdropView: 0x7a69fe00; frame = (0 0; 270 122); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;<em>UIBackdropViewLayer: 0x7a692a40>>
   |    |    |    |    |    | &lt;UIView: 0x7a694d00; frame = (0 0; 270 122); opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a6746d0>>
   |    |    |    | &lt;UIView: 0x7a696410; frame = (0 0; 270 122); layer = &lt;CALayer: 0x7a696480>>
   |    |    |    |    | &lt;UIView: 0x7a6964d0; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a696540>>
   |    |    |    |    |    | &lt;</em>UIAlertControllerShadowedScrollView: 0x7a6966b0; frame = (0 0; 270 78); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7a696e60>; layer = &lt;CALayer: 0x7a6969c0>; contentOffset: {0, 0}; contentSize: {270, 78}>
   |    |    |    |    |    |    | &lt;UIView: 0x7a6975c0; frame = (0 0; 270 78); layer = &lt;CALayer: 0x7a697630>>
   |    |    |    |    |    |    |    | &lt;UILabel: 0x7a698580; frame = (16 20; 238 21); text = &lsquo;11&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7a698240>>
   |    |    |    |    |    |    |    | &lt;UILabel: 0x7a69ab30; frame = (16 42; 238 16); text = &lsquo;22&rsquo;; userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7a69abf0>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7a69ad70; frame = (135 -451; 0 0); clipsToBounds = YES; layer = &lt;CALayer: 0x7a69ade0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a787b60; frame = (0 75; 270 3); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a787e70>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a788610; frame = (267 902; 3 78); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a788690>>
   |    |    |    |    |    | &lt;UICollectionView: 0x7a984a00; frame = (0 78; 270 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7a69bd70>; layer = &lt;CALayer: 0x7a69bad0>; contentOffset: {0, 0}; contentSize: {270, 44}> collection view layout: &lt;<em>UIAlertControllerCollectionViewFlowLayout: 0x7a69b1d0>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerCollectionViewCell: 0x7bbbaec0; frame = (0 1; 135 44); layer = &lt;CALayer: 0x7bbbd730>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7bbbc4a0; frame = (0 0; 135 44); gestureRecognizers = &lt;NSArray: 0x7bbb11b0>; layer = &lt;CALayer: 0x7bbc2110>>
   |    |    |    |    |    |    |    |    | &lt;<em>UIAlertControllerActionView: 0x7bbbc100; frame = (0 0; 135 44); Action = &lt;UIAlertAction: 0x7bbbf640 Title = &ldquo;cancel&rdquo; Descriptive = &ldquo;(null)&rdquo; Image = 0x0>>
   |    |    |    |    |    |    |    |    |    | &lt;</em>UIBlendingHighlightView: 0x7bbc5640; frame = (0 0; 135 44); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbc5810>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc56e0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbc4dd0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc5790; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbc6580>>
   |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc28e0; frame = (12 0; 111 0); layer = &lt;CALayer: 0x7bb68f30>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbbc1c0; frame = (0 12; 111 21); text = &lsquo;cancel&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7bbbd3e0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbbc280; frame = (-12 22; 0 0); userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7bbc1c50>>
   |    |    |    |    |    |    |    |    |    |    |    | &lt;<em>UILabelContentLayer: 0x7a7b5620> (layer)
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbbc340; frame = (12 22; 0 0); userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbbc3c0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbbfe30; frame = (109 15; 14 14); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbc2d30>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerCollectionViewCell: 0x7bbcd6c0; frame = (135 1; 135 44); layer = &lt;CALayer: 0x7bbcd2a0>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7bbcd760; frame = (0 0; 135 44); gestureRecognizers = &lt;NSArray: 0x7bbcd950>; layer = &lt;CALayer: 0x7bbcd7d0>>
   |    |    |    |    |    |    |    |    | &lt;<em>UIAlertControllerActionView: 0x7bbcd980; frame = (0 0; 135 44); Action = &lt;UIAlertAction: 0x7bbbf7c0 Title = &ldquo;OK&rdquo; Descriptive = &ldquo;(null)&rdquo; Image = 0x0>>
   |    |    |    |    |    |    |    |    |    | &lt;</em>UIBlendingHighlightView: 0x7bbd0550; frame = (0 0; 135 44); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbd1e30>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbd05f0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbd0060>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbd06a0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbd2bf0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbcda70; frame = (12 0; 111 0); layer = &lt;CALayer: 0x7bbcdae0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbcdb10; frame = (0 12; 111 21); text = &lsquo;OK&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7bbcdbd0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbcdd20; frame = (-12 22; 0 0); userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7bbcdde0>>
   |    |    |    |    |    |    |    |    |    |    |    | &lt;<em>UILabelContentLayer: 0x7a7b50d0> (layer)
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbcdf30; frame = (12 22; 0 0); userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbcdfb0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbcdfe0; frame = (109 15; 14 14); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbce060>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerBlendingSeparatorView: 0x7a7739b0; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a78d6b0>>
   |    |    |    |    |    |    |    | &lt;<em>UIBlendingHighlightView: 0x7a774ac0; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a7926e0>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a77f430; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a792760>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a785440; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a7927c0>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerBlendingSeparatorView: 0x7a780ab0; frame = (135 1; 1 43); layer = &lt;CALayer: 0x7a79d5a0>>
   |    |    |    |    |    |    |    | &lt;_UIBlendingHighlightView: 0x7a78c490; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a7928e0>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a7beba0; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a792960>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a772d20; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a7929e0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a789f20; frame = (0 41; 270 3); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a789fa0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a78a3e0; frame = (267 0; 3 44); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a78a460>></p>

<p>&#8220;`</p>

<p>可以看到，虽然UIAlertView在iOS7和iOS8中实现方法不同，但都是新建了一个UIWindow，并设为keyWindow。<br/>
模仿UIAlertView的方式，做了<a href="https://github.com/iandai/RTOverlayWindow">RTOverlayWindow</a>。<br/>
需要注意的是，使用多层UIWindow也是苹果所不推荐的方法，不过有时候在代码结构本身不合理的情况下，也是一种不错的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App如何正确的要求用户同意获取系统权限（摘要）]]></title>
    <link href="http://iandai.github.io/blog/2015/09/24/ios-appru-he-zheng-que-de-yao-qiu-yong-hu-tong-yi-huo-qu-xi-tong-quan-xian-(zhai-yao-)/"/>
    <updated>2015-09-24T11:30:22+02:00</updated>
    <id>http://iandai.github.io/blog/2015/09/24/ios-appru-he-zheng-que-de-yao-qiu-yong-hu-tong-yi-huo-qu-xi-tong-quan-xian-(zhai-yao-)</id>
    <content type="html"><![CDATA[<h2>iOS App如何正确的要求用户同意获取系统权限（摘要）</h2>

<ul>
<li>App下载后，第一次初始化的时候，弹出对话框，要求获取系统权限。成功率只有30%－40%。这种方法不推荐。</li>
<li>在给用户介绍App功能的界面，解释为什么需要获取某一项系统权限，并弹出对话框。成功率有40% - 66%。这种方法也不推荐。</li>
<li>在用户进行某项操作，必须使用到某一项系统权限的时候，弹出App自定义的对话框，解释为何需要获取某一项系统权限。如果用户点击同意，那么再弹出系统的权限获取对话框。如果用户点击不同意，那么App就不执行该功能，告诉用户要做的操作失败。利用这种方法，有时候成功率可以达到100%。</li>
</ul>


<h4>参考文献</h4>

<p><a href="http://techcrunch.com/2014/04/04/the-right-way-to-ask-users-for-ios-permissions/">The Right Way To Ask Users For iOS Permissions</a></p>
]]></content>
  </entry>
  
</feed>
