<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Ian's Tech Note]]></title>
  <link href="http://iandai.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://iandai.github.io/"/>
  <updated>2016-08-20T23:39:24+08:00</updated>
  <id>http://iandai.github.io/</id>
  <author>
    <name><![CDATA[Ian Dai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Optional in Swift -- 使用Swift Optional的好处]]></title>
    <link href="http://iandai.github.io/blog/2016/08/20/optional-in-swift-shi-yong-swift-optionalde-hao-chu/"/>
    <updated>2016-08-20T22:57:38+08:00</updated>
    <id>http://iandai.github.io/blog/2016/08/20/optional-in-swift-shi-yong-swift-optionalde-hao-chu</id>
    <content type="html"><![CDATA[<p>看这篇文章之前，需要了解Swift中<a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson1.html#//apple_ref/doc/uid/TP40015214-CH3-SW1">Optional的基础知识</a>。</p>

<p>作为写了几年的Objective-c的开发者，对在Swift中使用Optional持有过怀疑态度。使用了Optional，需要添加烦人的？和！。使用了？和！之后，依然需要做nil检查；使用了Value！之后，依然会在运行时因为nil问题而crash。</p>

<p>使用Optional有什么意义呢？</p>

<h2>使用理由1: 预先定义好通用的对象不存在的时候的写法</h2>

<p>考虑下面的例子：</p>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return nil;
}
</code></pre>

<p>可以使用findStockCode:方法来获取某个上市公司的股票代码。<br/>
也有的开发者会使用下面的方法来写，找不到的时候返回空字符串。</p>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return "";
}
</code></pre>

<p>如何确定找不到该公司代码的时候，返回的是空字符串还是nil呢？调用该方法的开发者，需要阅读文档或者处理多种情况。</p>

<pre><code class="objc">NSString *stockCode = [self findStockCode:@"Facebook"]; 
if (stockCode == "" &amp;&amp; stockCode == nil) {
    .....
}
</code></pre>

<p>在Swift中，这种情况非常明显的要使用Optional。如果找不到，则返回nil。</p>

<pre><code class="swift">func findStockCode (company : String) -&gt; String? {
    if (company == "Apple") {
        return "AAPL"
    } else if(company == "Google") {
        return "GOOG"
    }

    return nil
}
</code></pre>

<h2>使用理由2: 编译的时候提示错误</h2>

<pre><code class="objc">- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@"Apple"]) {
        return @"AAPL";
    } else if ([company isEqualToString:@"Google"]) {
        return @"GOOG";
    }

    return nil;
}

NSString *stockCode = [self findStockCode:@"Facebook"]; // nil is returned
NSString *text = @"Stock Code - ";
NSString *message = [text stringByAppendingString:stockCode]; // runtime error
NSLog(@"%@", message);
</code></pre>

<p>当用Objective-C的时候，<code>[text stringByAppendingString:stockCode]</code>中，给NSString添加nil的时候，在运行时出错。</p>

<pre><code class="swift">func findStockCode(company: String) -&gt; String? {
   if (company == "Apple") {
      return "AAPL"
   } else if (company == "Google") {
      return "GOOG"
   }

   return nil
}

var stockCode:String? = findStockCode("Facebook")
let text = "Stock Code - "
let message = text + stockCode  // compile-time error
print(message)
</code></pre>

<p>当用Swift的时候，<code>let message = text + stockCode</code>中，Xcode会主动提示stockCode可能会是nil的情况，需要开发者进一步处理。</p>

<h2>使用理由3: 强迫思考nil问题，crash容易发现问题</h2>

<p>上面的Swift代码中，要解决complile-time error，可以用加！来forced unwrapping。</p>

<pre><code class="swift">var stockCode:String? = findStockCode("Facebook")
let text = "Stock Code - "
let message = text + stockCode!  // runtime error
</code></pre>

<p>这段代码可以通过编译，但是在runtime的时候，还是会出错。<br/>
抛出：“fatal error: Can’t unwrap Optional.None”。<br/>
在使用！进行forced unwrapping的时候，开发者被迫思考是要forced unwrapping，还是stockCode有可能是nil。<br/>
这有利于减少犯错的机会。而如果出错了，提示的消息也非常容易找到问题所在。</p>

<h2>使用理由4: 简化nil检查写法(optional chaining)</h2>

<p>考虑这个例子</p>

<pre><code class="swift">class Stock {
    var code: String? 
    var price: Double? 
}

func findStockCode(company: String) -&gt; Stock? {
    if (company == "Apple") {
        let aapl: Stock = Stock()
        aapl.code = "AAPL"
        aapl.price = 90.32

        return aapl
    } else if (company == "Google") {
        let goog: Stock = Stock()
        goog.code = "GOOG"
        goog.price = 556.36

        return goog
    }

    return nil
}

if let sharePrice = findStockCode("Apple")?.price {
    let totalCost = sharePrice * 100
    print(totalCost)
}
</code></pre>

<p>在这段代码中，进行了2次nil检查，一次是判断findStockCode(&ldquo;Apple&rdquo;)是否为nil，一次是判断findStockCode(&ldquo;Apple&rdquo;).price是否为nil。使用optional chaining，可以简化nil检查写法。</p>

<h3>参考文献</h3>

<p><a href="https://www.appcoda.com/beginners-guide-optionals-swift/">A Beginner’s Guide to Optionals in Swift</a><br/>
<a href="http://blog.teamtreehouse.com/understanding-optionals-swift">Understanding Optionals in Swift</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模仿UIAlertView的一个Rotatable Overlay View — RTOverlayWindow]]></title>
    <link href="http://iandai.github.io/blog/2015/10/09/mo-fang-uialertviewde-%5B%3F%5D-ge-rotatable-overlay-view-rtoverlaywindow/"/>
    <updated>2015-10-09T21:37:41+08:00</updated>
    <id>http://iandai.github.io/blog/2015/10/09/mo-fang-uialertviewde-[?]-ge-rotatable-overlay-view-rtoverlaywindow</id>
    <content type="html"><![CDATA[<p>在写customised alert view的时候，遇到了一些问题，于是写了RTOverlayWindow。</p>

<p>最简单添加OverlayView的方法（苹果官方并不推荐使用这种方法），就是</p>

<pre><code class="objc">    UIWindow *keyWindow = [[UIApplication sharedApplication] keyWindow];
    [keyWindow addSubview:someCustomizedView];
</code></pre>

<p>使用上面的方法，添加的<code>someCustomizedView</code>无法自动旋转。
对无法自动旋转，最合理的解决方法，是把这个view放到一个UIViewController里面管理。</p>

<p>但是，还是希望有一种简单的方法，和使用UIAlertView一样，只是单纯的添加一个简单的view，就可以方便的使用。<br/>
于是研究了一下UIAlertView的实现。</p>

<p>在iOS7中，在界面有UIAlertView弹出的状态下，使用<code>po [[UIWindow keyWindow] recursiveDescription]</code>可以看到当前UIAlertView的view结构。</p>

<pre><code>&lt;_UIModalItemHostingWindow: 0x7af46ee0; frame = (0 0; 320 480); gestureRecognizers = &lt;NSArray: 0x7af473e0&gt;; layer = &lt;UIWindowLayer: 0x7af47060&gt;&gt;
   | &lt;UIView: 0x7af46dd0; frame = (0 0; 320 480); opaque = NO; autoresize = W+H; layer = &lt;CALayer: 0x7af46d60&gt;&gt;
   | &lt;UIView: 0x7af49800; frame = (0 0; 320 480); opaque = NO; autoresize = W+H; layer = &lt;CALayer: 0x7af49860&gt;&gt;
   |    | &lt;UIView: 0x7b2561f0; frame = (0 0; 320 480); layer = &lt;CALayer: 0x7b256250&gt;&gt;
   |    | &lt;_UIModalItemRepresentationView: 0x7b255d90; frame = (25 178; 270 124); layer = &lt;CALayer: 0x7b255ea0&gt;&gt;
   |    |    | &lt;_UIModalItemAlertBackgroundView: 0x7af30f80; frame = (0 0; 270 124); animations = { &lt;_UIParallaxMotionEffect: 0x7af4c470&gt;=&lt;CAAnimationGroup: 0x7b25e510&gt;; }; layer = &lt;CALayer: 0x7af312e0&gt;&gt;
   |    |    |    | &lt;_UIBackdropView: 0x7af3de20; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;_UIBackdropViewLayer: 0x7af4a290&gt;&gt;
   |    |    |    |    | &lt;_UIBackdropEffectView: 0x7af4ab30; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CABackdropLayer: 0x7af4ae50&gt;&gt;
   |    |    |    |    | &lt;UIView: 0x7af4b150; frame = (0 0; 270 124); hidden = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7af4b5c0&gt;&gt;
   |    |    |    | &lt;UIImageView: 0x7af3b830; frame = (0 0; 270 124); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7af47020&gt;&gt;
   |    |    | &lt;_UIModalItemAlertContentView: 0x7af45b50; frame = (0 0; 270 124); clipsToBounds = YES; animations = { &lt;_UIParallaxMotionEffect: 0x7af4c470&gt;=&lt;CAAnimationGroup: 0x7b25ec90&gt;; }; layer = &lt;CALayer: 0x7af45cf0&gt;&gt;
   |    |    |    | &lt;UITableView: 0x7cb96000; frame = (135 80; 135 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b236eb0&gt;; layer = &lt;CALayer: 0x7b236960&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UITableViewWrapperView: 0x7b2378f0; frame = (0 0; 135 44); autoresize = W+H; layer = &lt;CALayer: 0x7b237a00&gt;&gt;
   |    |    |    |    |    | &lt;_UIModalItemTableViewCell: 0x7b2648c0; frame = (0 0; 135 44); text = 'OK'; autoresize = W; layer = &lt;CALayer: 0x7b256010&gt;&gt;
   |    |    |    |    |    |    | &lt;UITableViewCellScrollView: 0x7b264a60; frame = (0 0; 135 44); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7b237d50&gt;; layer = &lt;CALayer: 0x7b2604b0&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    |    |    |    | &lt;UITableViewCellContentView: 0x7b2520e0; frame = (0 0; 135 43.5); gestureRecognizers = &lt;NSArray: 0x7b261de0&gt;; layer = &lt;CALayer: 0x7b261220&gt;&gt;
   |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7b264d30; frame = (15 0; 105 43.5); text = 'OK'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b255ed0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b2577b0; frame = (131.5 37; 3.5 7); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b257880&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b2571d0; frame = (128 40.5; 7 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b257420&gt;&gt;
   |    |    |    | &lt;UIScrollView: 0x7b238430; frame = (0 0; 270 61); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b2389a0&gt;; layer = &lt;CALayer: 0x7b238680&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UILabel: 0x7b2337a0; frame = (15 19; 240 21); text = 'title'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b233850&gt;&gt;
   |    |    |    |    | &lt;UILabel: 0x7b2340a0; frame = (15 44; 240 17); text = 'message'; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b233950&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b258bd0; frame = (0 57.5; 270 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b258ca0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b258da0; frame = (266.5 0; 3.5 61); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b258e70&gt;&gt;
   |    |    |    | &lt;UIView: 0x7b2541d0; frame = (0 79.5; 270 0.5); layer = &lt;CALayer: 0x7b254230&gt;&gt;
   |    |    |    | &lt;UITableView: 0x7cbc7400; frame = (0 80; 135 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7b254320&gt;; layer = &lt;CALayer: 0x7b2542b0&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    | &lt;UITableViewWrapperView: 0x7b254620; frame = (0 0; 135 44); autoresize = W+H; layer = &lt;CALayer: 0x7b254710&gt;&gt;
   |    |    |    |    |    | &lt;_UIModalItemTableViewCell: 0x7b25fb20; frame = (0 0; 135 44); text = 'cancel'; autoresize = W; layer = &lt;CALayer: 0x7b25fe00&gt;&gt;
   |    |    |    |    |    |    | &lt;UITableViewCellScrollView: 0x7b2600c0; frame = (0 0; 135 44); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7b236cf0&gt;; layer = &lt;CALayer: 0x7b260330&gt;; contentOffset: {0, 0}&gt;
   |    |    |    |    |    |    |    | &lt;UITableViewCellContentView: 0x7b2368e0; frame = (0 0; 135 43.5); gestureRecognizers = &lt;NSArray: 0x7b256cd0&gt;; layer = &lt;CALayer: 0x7b237f90&gt;&gt;
   |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7b237a30; frame = (15 0; 105 43.5); text = 'cancel'; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b25b8a0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b259200; frame = (131.5 37; 3.5 7); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b2592d0&gt;&gt;
   |    |    |    |    | &lt;UIImageView: 0x7b259020; frame = (128 40.5; 7 3.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7b2590f0&gt;&gt;
   |    |    |    | &lt;UIView: 0x7b254820; frame = (135 80; 0.5 44); layer = &lt;CALayer: 0x7b254880&gt;&gt;
</code></pre>

<p>在iOS8中UIVAlertView结构如下。
&#8220;`
&lt;<em>UIAlertControllerShimPresenterWindow: 0x7bbbfaa0; frame = (0 0; 768 1024); opaque = NO; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x7bbc0600>; layer = &lt;UIWindowLayer: 0x7bbbfcf0>>
   | &lt;UIView: 0x7bd727b0; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x7bd72820>>
   | &lt;UITransitionView: 0x7a7bcb20; frame = (0 0; 768 1024); autoresize = W+H; layer = &lt;CALayer: 0x7a7bccd0>>
   |    | &lt;UIView: 0x7a68fd90; frame = (0 0; 768 1024); layer = &lt;CALayer: 0x7a68fe00>>
   |    | &lt;</em>UIKeyboardLayoutAlignmentView: 0x7a68fab0; frame = (0 1024; 768 0); layer = &lt;CALayer: 0x7a68fc60>>
   |    | &lt;UIView: 0x7a68f8e0; frame = (0 0; 768 1024); layer = &lt;CALayer: 0x7a68f890>>
   |    | &lt;<em>UIAlertControllerView: 0x7a695f70; frame = (249 451; 270 122); layer = &lt;CALayer: 0x7a6961e0>>
   |    |    | &lt;UIView: 0x7a696350; frame = (0 0; 270 122); animations = { &lt;</em>UIParallaxMotionEffect: 0x7a792160>=&lt;CAAnimationGroup: 0x7a7b2380>; }; layer = &lt;CALayer: 0x7a6963c0>>
   |    |    |    | &lt;<em>UIDimmingKnockoutBackdropView: 0x7a69fd90; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a689fa0>>
   |    |    |    |    | &lt;UIView: 0x7a68a490; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a687850>>
   |    |    |    |    | &lt;</em>UIBackdropView: 0x7a69fe00; frame = (0 0; 270 122); clipsToBounds = YES; opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;<em>UIBackdropViewLayer: 0x7a692a40>>
   |    |    |    |    |    | &lt;UIView: 0x7a694d00; frame = (0 0; 270 122); opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a6746d0>>
   |    |    |    | &lt;UIView: 0x7a696410; frame = (0 0; 270 122); layer = &lt;CALayer: 0x7a696480>>
   |    |    |    |    | &lt;UIView: 0x7a6964d0; frame = (0 0; 270 122); clipsToBounds = YES; layer = &lt;CALayer: 0x7a696540>>
   |    |    |    |    |    | &lt;</em>UIAlertControllerShadowedScrollView: 0x7a6966b0; frame = (0 0; 270 78); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7a696e60>; layer = &lt;CALayer: 0x7a6969c0>; contentOffset: {0, 0}; contentSize: {270, 78}>
   |    |    |    |    |    |    | &lt;UIView: 0x7a6975c0; frame = (0 0; 270 78); layer = &lt;CALayer: 0x7a697630>>
   |    |    |    |    |    |    |    | &lt;UILabel: 0x7a698580; frame = (16 20; 238 21); text = &lsquo;11&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7a698240>>
   |    |    |    |    |    |    |    | &lt;UILabel: 0x7a69ab30; frame = (16 42; 238 16); text = &lsquo;22&rsquo;; userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7a69abf0>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7a69ad70; frame = (135 -451; 0 0); clipsToBounds = YES; layer = &lt;CALayer: 0x7a69ade0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a787b60; frame = (0 75; 270 3); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a787e70>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a788610; frame = (267 902; 3 78); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a788690>>
   |    |    |    |    |    | &lt;UICollectionView: 0x7a984a00; frame = (0 78; 270 44); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7a69bd70>; layer = &lt;CALayer: 0x7a69bad0>; contentOffset: {0, 0}; contentSize: {270, 44}> collection view layout: &lt;<em>UIAlertControllerCollectionViewFlowLayout: 0x7a69b1d0>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerCollectionViewCell: 0x7bbbaec0; frame = (0 1; 135 44); layer = &lt;CALayer: 0x7bbbd730>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7bbbc4a0; frame = (0 0; 135 44); gestureRecognizers = &lt;NSArray: 0x7bbb11b0>; layer = &lt;CALayer: 0x7bbc2110>>
   |    |    |    |    |    |    |    |    | &lt;<em>UIAlertControllerActionView: 0x7bbbc100; frame = (0 0; 135 44); Action = &lt;UIAlertAction: 0x7bbbf640 Title = &ldquo;cancel&rdquo; Descriptive = &ldquo;(null)&rdquo; Image = 0x0>>
   |    |    |    |    |    |    |    |    |    | &lt;</em>UIBlendingHighlightView: 0x7bbc5640; frame = (0 0; 135 44); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbc5810>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc56e0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbc4dd0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc5790; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbc6580>>
   |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbc28e0; frame = (12 0; 111 0); layer = &lt;CALayer: 0x7bb68f30>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbbc1c0; frame = (0 12; 111 21); text = &lsquo;cancel&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7bbbd3e0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbbc280; frame = (-12 22; 0 0); userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7bbc1c50>>
   |    |    |    |    |    |    |    |    |    |    |    | &lt;<em>UILabelContentLayer: 0x7a7b5620> (layer)
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbbc340; frame = (12 22; 0 0); userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbbc3c0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbbfe30; frame = (109 15; 14 14); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbc2d30>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerCollectionViewCell: 0x7bbcd6c0; frame = (135 1; 135 44); layer = &lt;CALayer: 0x7bbcd2a0>>
   |    |    |    |    |    |    |    | &lt;UIView: 0x7bbcd760; frame = (0 0; 135 44); gestureRecognizers = &lt;NSArray: 0x7bbcd950>; layer = &lt;CALayer: 0x7bbcd7d0>>
   |    |    |    |    |    |    |    |    | &lt;<em>UIAlertControllerActionView: 0x7bbcd980; frame = (0 0; 135 44); Action = &lt;UIAlertAction: 0x7bbbf7c0 Title = &ldquo;OK&rdquo; Descriptive = &ldquo;(null)&rdquo; Image = 0x0>>
   |    |    |    |    |    |    |    |    |    | &lt;</em>UIBlendingHighlightView: 0x7bbd0550; frame = (0 0; 135 44); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbd1e30>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbd05f0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbd0060>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbd06a0; frame = (0 0; 135 44); layer = &lt;CALayer: 0x7bbd2bf0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIView: 0x7bbcda70; frame = (12 0; 111 0); layer = &lt;CALayer: 0x7bbcdae0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbcdb10; frame = (0 12; 111 21); text = &lsquo;OK&rsquo;; userInteractionEnabled = NO; layer = &lt;<em>UILabelLayer: 0x7bbcdbd0>>
   |    |    |    |    |    |    |    |    |    |    | &lt;UILabel: 0x7bbcdd20; frame = (-12 22; 0 0); userInteractionEnabled = NO; layer = &lt;</em>UILabelLayer: 0x7bbcdde0>>
   |    |    |    |    |    |    |    |    |    |    |    | &lt;<em>UILabelContentLayer: 0x7a7b50d0> (layer)
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbcdf30; frame = (12 22; 0 0); userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbcdfb0>>
   |    |    |    |    |    |    |    |    |    | &lt;UIImageView: 0x7bbcdfe0; frame = (109 15; 14 14); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7bbce060>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerBlendingSeparatorView: 0x7a7739b0; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a78d6b0>>
   |    |    |    |    |    |    |    | &lt;<em>UIBlendingHighlightView: 0x7a774ac0; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a7926e0>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a77f430; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a792760>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a785440; frame = (0 0; 270 1); layer = &lt;CALayer: 0x7a7927c0>>
   |    |    |    |    |    |    | &lt;</em>UIAlertControllerBlendingSeparatorView: 0x7a780ab0; frame = (135 1; 1 43); layer = &lt;CALayer: 0x7a79d5a0>>
   |    |    |    |    |    |    |    | &lt;_UIBlendingHighlightView: 0x7a78c490; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a7928e0>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a7beba0; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a792960>>
   |    |    |    |    |    |    |    |    | &lt;UIView: 0x7a772d20; frame = (0 0; 1 43); layer = &lt;CALayer: 0x7a7929e0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a789f20; frame = (0 41; 270 3); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a789fa0>>
   |    |    |    |    |    |    | &lt;UIImageView: 0x7a78a3e0; frame = (267 0; 3 44); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7a78a460>></p>

<p>&#8220;`</p>

<p>可以看到，虽然UIAlertView在iOS7和iOS8中实现方法不同，但都是新建了一个UIWindow，并设为keyWindow。<br/>
模仿UIAlertView的方式，做了<a href="https://github.com/iandai/RTOverlayWindow">RTOverlayWindow</a>。<br/>
需要注意的是，使用多层UIWindow也是苹果所不推荐的方法，不过有时候在代码结构本身不合理的情况下，也是一种不错的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App如何正确的要求用户同意获取系统权限（摘要）]]></title>
    <link href="http://iandai.github.io/blog/2015/09/24/ios-appru-he-zheng-que-de-yao-qiu-yong-hu-tong-yi-huo-qu-xi-tong-quan-xian-(zhai-yao-)/"/>
    <updated>2015-09-24T17:30:22+08:00</updated>
    <id>http://iandai.github.io/blog/2015/09/24/ios-appru-he-zheng-que-de-yao-qiu-yong-hu-tong-yi-huo-qu-xi-tong-quan-xian-(zhai-yao-)</id>
    <content type="html"><![CDATA[<h2>iOS App如何正确的要求用户同意获取系统权限（摘要）</h2>

<ul>
<li>App下载后，第一次初始化的时候，弹出对话框，要求获取系统权限。成功率只有30%－40%。这种方法不推荐。</li>
<li>在给用户介绍App功能的界面，解释为什么需要获取某一项系统权限，并弹出对话框。成功率有40% - 66%。这种方法也不推荐。</li>
<li>在用户进行某项操作，必须使用到某一项系统权限的时候，弹出App自定义的对话框，解释为何需要获取某一项系统权限。如果用户点击同意，那么再弹出系统的权限获取对话框。如果用户点击不同意，那么App就不执行该功能，告诉用户要做的操作失败。利用这种方法，有时候成功率可以达到100%。</li>
</ul>


<h4>参考文献</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS在删除App的情况下，仍然会记忆App Camera访问权限的reset方法]]></title>
    <link href="http://iandai.github.io/blog/2015/09/24/iozai-shan-chu-appde-qing-kuang-xia-,reng-ran-hui-ji-yi-app-camerafang-wen-quan-xian-de-resetfang-fa/"/>
    <updated>2015-09-24T16:50:50+08:00</updated>
    <id>http://iandai.github.io/blog/2015/09/24/iozai-shan-chu-appde-qing-kuang-xia-,reng-ran-hui-ji-yi-app-camerafang-wen-quan-xian-de-resetfang-fa</id>
    <content type="html"><![CDATA[<h2>重设App相机访问权限方法</h2>

<ul>
<li>iOS在删除App的情况下，仍然会记忆App camera访问权限1天</li>
<li>重设方法一：调整系统时间。</li>
<li>重设方法二：修改App的bundle id。</li>
<li>重设方法三：重设所有App的位置和隐私。Settings -> General -> Reset -> Rest Location &amp; Privacy</li>
</ul>


<h4>参考文献</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高性能添加图片圆角方法原理：cornerRadius，layer.shouldRasterize，layer.setShadowPath和透明图片]]></title>
    <link href="http://iandai.github.io/blog/2015/09/21/gao-xing-neng-tian-jia-tu-pian-yuan-jiao-fang-fa-bi-jiao-:layer-dot-shouldrasterize,layer-dot-setshadowpathhe-tou-ming-tu-pian/"/>
    <updated>2015-09-21T20:07:34+08:00</updated>
    <id>http://iandai.github.io/blog/2015/09/21/gao-xing-neng-tian-jia-tu-pian-yuan-jiao-fang-fa-bi-jiao-:layer-dot-shouldrasterize,layer-dot-setshadowpathhe-tou-ming-tu-pian</id>
    <content type="html"><![CDATA[<h2>在layer上添加cornerRadius原理</h2>

<pre><code class="objc">UIImage *image = [UIImage imageNamed:@"sample"];
//顺便提一句，imageNamed这个方法会cache image。

UIImageView *imgView = [[UIImageView alloc] initWithImage:image];
imgView.layer.masksToBounds = YES;
//等同于view.clipsToBounds ＝ YES

imgView.layer.cornerRadius = 0.5f;
</code></pre>

<ul>
<li><p>调用cornerRadius的时候，系统会做什么？
设置cornerRadius，会在layer的background上面绘制圆角。默认情况下，这并不会应用到layer的contents属性上的图片（每个layer中contents属性接受一个CGImage的对象）。
设置masksToBounds属性为YES，并且设置cornerRadius的值的话，Core Animation会创建一个包含圆角效果的蒙板（mask）。 这使得layer的contents属性中的图片在蒙板作用下，产生圆角效果[1]。</p></li>
<li><p>为什么在uitableview或者uicollectionview中滚动的时候，给图片添加圆角直接用cornerRadius性能不好？
当layer的属性cornerRadius和maskToBounds一起使用时，会触发离屏渲染（Offscreen rendering）。</p></li>
<li><p>离屏渲染Offscreen rendering是什么呢？
Offscreen rendring指的是在图像在绘制到当前屏幕前，需要先渲染到一个Offscreen context，之后才绘制到屏幕。当Offscreen rendering频繁发生的时候，就会降低性能[2]。
－－－
这里提到的offscreen rendering主要讲的是通过GPU执行的offscreen,事实上还有的offscreen rendering是通过CPU来执行的（例如使用Core Graphics, drawRect）。其它类似cornerRadios, masks, shadows等触发的offscreen是基于GPU的。［4］
－－－
但是2014 wwdc那个例子里面没有提到这部分内容。</p></li>
<li><p>离屏渲染Offscreen rendering的可能误解。</p></li>
</ul>


<p>Offscreen rendering
Offscreen rendering is drawing, that cannot be done using hardware acceleration (GPU) and should be performed on the CPU instead.
At the low level this looks like that: during rendering of the layer that requires the offscreen rendering, the GPU stops the rendering pipeline and passes control to the CPU. In its turn, the CPU performs all the necessary operations (e.g. your fancy stuff in drawRect:) and returns control to the GPU with the already rendered layer. GPU renders it and the rendering pipeline keeps going.</p>

<p><a href="https://yalantis.com/blog/mastering-uikit-performance/">https://yalantis.com/blog/mastering-uikit-performance/</a></p>

<p>以上对Offscreen rendering解释是错误的！</p>

<ul>
<li>为什么cornerRadius和maskToBounds一起使用时，会触发离屏渲染？
cornerRadius和maskToBounds一起使用时，Core Animation会创建一个包含圆角效果的蒙板（mask）。
Offscreen rendering会在layer的各种属性结合，使得layer不能直接绘制到屏幕上，需要进行pre-compositing的时候，会触发离屏渲染。
（原文：Offscreen rendering is invoked whenever the combinnation of layer propertyies that have been specified mean that the layer cannot
be drawn directly to the screen without pre-compositing.）［3］</li>
</ul>


<p>搜索找一个可能的解决方案
opengl layer mask
<a href="https://www.google.co.jp/search?q=opengl+layer+mask&amp;oq=opengl+layer+mask&amp;aqs=chrome..69i57.2662j0j7&amp;sourceid=chrome&amp;es_sm=119&amp;ie=UTF-8">https://www.google.co.jp/search?q=opengl+layer+mask&amp;oq=opengl+layer+mask&amp;aqs=chrome..69i57.2662j0j7&amp;sourceid=chrome&amp;es_sm=119&amp;ie=UTF-8</a></p>

<p><a href="https://lobste.rs/s/ckm4uw/a_performance-minded_take_on_ios_design">https://lobste.rs/s/ckm4uw/a_performance-minded_take_on_ios_design</a>
CPU GPU offscreen rendering</p>

<p><a href="http://objccn.io/issue-3-1/">http://objccn.io/issue-3-1/</a>
<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques/blob/master/15-%E5%9B%BE%E5%B1%82%E6%80%A7%E8%83%BD/15-%E5%9B%BE%E5%B1%82%E6%80%A7%E8%83%BD.md">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques/blob/master/15-%E5%9B%BE%E5%B1%82%E6%80%A7%E8%83%BD/15-%E5%9B%BE%E5%B1%82%E6%80%A7%E8%83%BD.md</a></p>

<p>改正这个
<a href="http://qiita.com/ykensuke/items/1bc3aa47e2a8c8b474f2">http://qiita.com/ykensuke/items/1bc3aa47e2a8c8b474f2</a></p>

<h2>可能提高性能的方法一：光栅化layer.shouldRasterize</h2>

<pre><code class="objc">UIImage *image = [UIImage imageNamed:@"sample"];
//顺便提一句，imageNamed这个方法会cache image。

UIImageView *imgView = [[UIImageView alloc] initWithImage:image];
imgView.layer.masksToBounds = YES;
//等同于view.clipsToBounds ＝ YES

imgView.layer.cornerRadius = 0.5f;
imgView.layer.shouldRasterize = YES;
</code></pre>

<ul>
<li><p>什么是光栅化（Rasterisation）？
Rasterisation (or rasterization) is the task of taking an image described in a vector graphics format (shapes) and converting it into a raster image (pixels or dots) for output on a video display or printer, or for storage in a bitmap file format.</p></li>
<li><p>为什么layer.shouldRasterize可能提高性能？
开启shouldRasterize后,layer会被光栅化为bitmap,layer的包含圆角的mask效果也会被保存到bitmap中。
要注意的是，更新已光栅化的layer，会造成大量的offscreen渲染。</p></li>
</ul>


<h2>可能提高性能的方法二：设置layer.shadowPath属性</h2>

<pre><code class="objc">UIImage *image = [UIImage imageNamed:@"sample"];
//顺便提一句，imageNamed这个方法会cache image。

UIImageView *imgView = [[UIImageView alloc] initWithImage:image];
imgView.layer.masksToBounds = YES;
//等同于view.clipsToBounds ＝ YES

imgView.layer.cornerRadius = 0.5f;
imgView.layer.shadowPath = [UIBezierPath bezierPathWithRect:imgView.bounds].CGPath;
</code></pre>

<ul>
<li>layer的shadowPath的理解
layer会创建一个圆角的shadowPath，并且会cache这个shadowPath，避免多次重绘。</li>
</ul>


<h2>可能提高性能的方法三：添加自带圆角中间透明的图片</h2>

<ul>
<li>这会cache圆角图片，但是在blending的时候，有透明的部分，会降低部分性能。
（利用一张中间为透明圆形的图片来进行遮盖,虽然会引起blending,但性能仍然高于offerScreen。）
来源：WWDC心得与延伸）</li>
</ul>


<h2>可能提高性能的方法四：CAShapeLayer</h2>

<h2>可能提高性能的方法五：drawRect</h2>

<h2>六 myView.layer.drawAsynchronously = YES</h2>

<p>当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 -drawRect:/-drawInContext: 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。</p>

<p>这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。</p>

<p>对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。</p>

<p>问题1: 整个过程是怎么样的？</p>

<p>当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这是一个很大的工作量。</p>

<p>第一步：
CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。
这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。</p>

<p>如果一个 CALayer 的子类实现了 -drawInContext: 或者它的代理，类似于 -drawLayer:inContest:, Core Animation 将会为这个图层申请一个后备存储，用来保存那些方法绘制进来的位图。那些方法内的代码将会运行在 CPU 上，结果将会被上传到 GPU。</p>

<p>第二步：
将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p>

<p>第三步：
GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。
每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。
GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。</p>

<p>We talk about hardware acceleration when the GPU is used for compositing and rendering graphics.
GPU (composition and rendering)?</p>

<p><a href="http://adcdownload.apple.com/wwdc_2012/wwdc_2012_session_pdfs/session_238__ios_app_performance_graphics_and_animations.pdf">http://adcdownload.apple.com/wwdc_2012/wwdc_2012_session_pdfs/session_238__ios_app_performance_graphics_and_animations.pdf</a>
• Layer properties and animations handled by render server</p>

<p>软件绘图
在iOS中，软件绘图通常是由Core Graphics框架完成来完成。
相比Core Animation和OpenGL，Core Graphics要慢了不少。
软件绘图不仅效率低，还会消耗可观的内存。
一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽<em>图层高</em>4字节，宽高的单位均为像素。
软件绘图的代价昂贵，除非绝对必要，你应该避免重绘你的视图。提高绘制性能的秘诀就在于尽量避免去绘制。
（drawRect的内容会被cache吗？）</p>

<p>问题2:shouldRasterize和shadowPath属性联系<br/>
都是在什么时候执行的？</p>

<p>结论
For good performance, the trick is to avoid using software drawing for views that change every frame.
1、多在不同设备上测试动画、他们的区别可能在于GPU, CPU, Retina blabla</p>

<p>2、不同场景有不同的解决方法，到底是用drawRect? 还是用SubView？</p>

<p>3、测量、测试、迭代  And as with all performance-related issues, you should use Instruments to measure and track the performance of your app over time so that you can ensure that performance is improving and not regressing.</p>

<p>参考文献：</p>

<p>[1]Apple Reference cornerRadius <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instp/CALayer/cornerRadius">https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instp/CALayer/cornerRadius</a>
[2]From iOS Core Animation: Advanced Techniques 的定义 <a href="https://books.google.co.jp/books?id=QfhdAAAAQBAJ&amp;pg=PT285&amp;lpg=PT285&amp;dq=mask+++Offscreen+Rendering&amp;source=bl&amp;ots=O7rQA5t516&amp;sig=Spp578t7gU5qLQDdltFjdbvqrhI&amp;hl=en&amp;sa=X&amp;ved=0CFoQ6AEwDGoVChMIrvzq9I6NyAIVAx-UCh0UygVl#v=onepage&amp;q&amp;f=false">https://books.google.co.jp/books?id=QfhdAAAAQBAJ&amp;pg=PT285&amp;lpg=PT285&amp;dq=mask+++Offscreen+Rendering&amp;source=bl&amp;ots=O7rQA5t516&amp;sig=Spp578t7gU5qLQDdltFjdbvqrhI&amp;hl=en&amp;sa=X&amp;ved=0CFoQ6AEwDGoVChMIrvzq9I6NyAIVAx-UCh0UygVl#v=onepage&amp;q&amp;f=false</a>
［3］(From iOS Core Animation: Advanced Techniques 的定义)
［4］WWDC心得与延伸:iOS图形性能中内容矛盾  <a href="http://www.cocoachina.com/ios/20150429/11712.html">http://www.cocoachina.com/ios/20150429/11712.html</a></p>

<p><a href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/">https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/</a>
<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques</a></p>

<p>WWDC心得与延伸:iOS图形性能
<a href="http://www.cocoachina.com/ios/20150429/11712.html">http://www.cocoachina.com/ios/20150429/11712.html</a></p>

<p><a href="http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios">http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios</a></p>

<p>Core Animation Programming Guide：Improving Animation Performance <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/ImprovingAnimationPerformance/ImprovingAnimationPerformance.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/ImprovingAnimationPerformance/ImprovingAnimationPerformance.html</a></p>

<p>离屏绘制(Offscreen drawing)优化性能，也就是shouldRasterize的实际做的事情，
<a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance">https://robots.thoughtbot.com/designing-for-ios-graphics-performance</a></p>

<p>更加深入的offscreen render分析：iOS离屏绘制的性能和机制分析（Apple UIKit teamer写的，这大概是终极牛逼的分析了）
<a href="http://www.taofengping.com/2013/05/18/ios_offscreen_analysis/#.VZZkuhOqpBc">http://www.taofengping.com/2013/05/18/ios_offscreen_analysis/#.VZZkuhOqpBc</a>
  当你实现drawRect方法或者通过CoeGraphics绘制的时候，其实你是在使用CPU绘制。</p>

<p>  还有需要注意的是，shouldRasterize和masking（遮罩）, shadows（阴影）, edge antialiasing,（抗锯齿），group opacity属性都不一样。如果后面这些提到的属性是开启的，就不会有缓存，并且离屏绘制将会在每一帧都发生? 这段话不对吧？ 是在只有多层layer的时候的表现吗？  不理解。</p>

<p>什么时候layer会offscreen rendering
<a href="http://stackoverflow.com/questions/6731545/when-does-a-view-or-layer-require-offscreen-rendering">http://stackoverflow.com/questions/6731545/when-does-a-view-or-layer-require-offscreen-rendering</a></p>

<p>What triggers offscreen rendering, blending and layoutSubviews in iOS?
<a href="http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios">http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios</a></p>

<p>测试性能
<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a>
<a href="http://stackoverflow.com/questions/5459708/measuring-the-uitableview-scrolling-performance-iphone">http://stackoverflow.com/questions/5459708/measuring-the-uitableview-scrolling-performance-iphone</a>
I&rsquo;d suggest using Instruments rather than trying to run the test directly in your code. The Core Animation tool will track the actual number of frames per second (FPS) that your app’s displaying.
60 is max you can get, and it&rsquo;s best if it&rsquo;s close to this value.
Typically you have to complete each call within 16ms so as to maintain smooth animation at 60fps.</p>

<p>如何加强 iOS 里的列表滚动时的顺畅感？
<a href="http://www.zhihu.com/question/20382396">http://www.zhihu.com/question/20382396</a></p>

<p>如果你想要如丝般顺滑的效果，那么：
1、每次都看一下有没有能重用的 cell，而不是永远重新新建（这个是 UITableView 的常识）
2、Cell 里尽量不要用 UIView 而是全部自己用 drawRect 画（之前因为 iOS 有 bug，这样做会有性能上质的飞越。也有很多大神写过很多文章解释原理，有兴趣的自己去看看吧我就不做复制粘贴了。后来 iOS 也改掉了这个问题，这么做的效果就没那么明显了。）
3、图片载入放到后台进程去进行，滚出可视范围的载入进程要 cancel 掉
4、圆角、阴影之类的全部 bitmap 化，或者放到后台 draw 好了再拿来用
5、Cell 里要用的数据提前缓存好，不要现用现去读文件
6、数据量太大来不及一次读完的做一个 load more cell 出来，尽量避免边滚边读数据，这样就算是双核的 CPU 也难保不会抽</p>
]]></content>
  </entry>
  
</feed>
